{
    "0": "Web Search: Web Indexing\n \n \nChengXiang\n \n\n \nDepartment of Computer Science\n \nUniversity of Illinois at Urbana\n-\nChampaign\n \n1\n \n",
    "1": "Web Search: Web Indexing\n \n2\n \nBig Text Data\n \nSmall Relevant Data\n \n  \nSearch Engine\n \nRecommender \n \nSystem\n \n2. Text Access\n \n11. \nRecommendation\n \n3. Text Retrieval Problem\n \n10. \nWeb Search\n \nUser\n \n1. Natural Language Content Analysis\n \n4. Text Retrieval Methods\n \n7\n. \nEvaluation \n \n6. System \n \nImplementation\n \n5\n. Vector Space Model\n \n8\n. Probabilistic Model \n \n9. Feedback  \n \n",
    "2": "3\n \nBasic Search Engine Technologies\n \nCached\n \npages\n \nCrawler\n \nWeb\n \n----\n \n----\n \n\n \n----\n \n----\n \n----\n \n----\n \n\n \n----\n \n----\n \n\n \nIndexer\n \n(Inverted) Index\n \n",
    "3": "4\n \nOverview of Web Indexing\n \n\nStandard IR techniques are the basis, but insufficient \n \n\nScalability \n \n\nEfficiency \n \n\n\n \n\nGoogle File System (GFS): distributed file system\n \n\nMapReduce\n: Software framework for parallel computation\n \n\nHadoop: Open source implementation of \nMapReduce\n \n",
    "4": "GFS Architecture\n \nFixed chunk size (64 MB)\n \nChunk is replicated\n \nto ensure reliability \n \nSimple centralized management \n \nData transfer is directly\n \n \nbetween application and \n \nchunk servers \n \nGHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.\n-\n\n \nthe nineteenth ACM symposium on Operating systems principles (New York, NY, USA, 2003), ACM, pp. 29\n\n43.\n \nhttp://\nstatic.googleusercontent.com/media/research.google.com/en/us/archive/gfs\n-\nsosp2003.pdf\n \n \n",
    "5": "MapReduce\n: A Framework for Parallel Programming \n \n\nMinimize effort of programmer for simple parallel \nprocessing tasks\n \n\nFeatures\n \n\nHide many low\n-\nlevel details (network, storage)\n \n\nBuilt\n-\nin fault tolerance  \n \n\nAutomatic load balancing \n \n6\n \n",
    "6": "MapReduce\n: Computation Pipeline\n \nMap(K,V)\n \nKey, Value\n \nKey, Value\n \nKey, Value\n \n\n \nKey, Value\n \nKey, Value\n \n\n \nKey, Value\n \nKey, Value\n \n\n \nReduce(K, V[ ])\n \nKey, Value\n \nKey, Value\n \n7\n \nInput \n\n \n \nMap(K,V)\n \nMap(K,V)\n \n\nOutput\n \n \nKey, Value\n \nKey, Value\n \nKey, Value\n \nMapReduce\n \nInternal Collection/Sorting\n \nSlide adapted from Alexander \nBehm\n \n& \nAjey\n \n\n://\nwww.slideshare.net/gothicane/behm\n-\nshah\n-\npagerank)\n \n",
    "7": "Word Counting\n \nOutput: \n \nCount of each word \n \nInput: Text Data\n \nHow can we do this within the \nMapReduce\n \nframework?\n \n \n8\n \nSlide adapted from Alexander \nBehm\n \n& \nAjey\n \n\n://\nwww.slideshare.net/gothicane/behm\n-\nshah\n-\npagerank)\n \nHello World Bye World\n \nHello Hadoop Bye Hadoop\n \nBye Hadoop Hello \nHadoop\n \n\n \nBye 3\n \nHadoop 4\n \nHello 3\n \nWorld \n2\n \n\n \n",
    "8": "Word Counting: Map Function\n \nInput\n \n \n1\n\n\n \n \n \n \n \n\n\n \n \n\n \n \nMap(K, V\n)\n \n \n{  \nFor each word w in \nV,   Collect(w\n, 1\n);}\n \n9\n \nSlide adapted from Alexander \nBehm\n \n& \nAjey\n \n\n://\nwww.slideshare.net/gothicane/behm\n-\nshah\n-\npagerank)\n \nMap(K,V)\n \n<Hello,1>\n \n<World,1>\n \n<Bye,1>\n \n<World,1>\n \n<Hello,1>\n \n<Hadoop,1\n>\n \n<Bye,1>\n \n<Hadoop,1\n>\n \nOutput\n \nMap(K,V)\n \n",
    "9": "Word Counting: Reduce Function\n \nReduce(K, V[ ]) \n \n{\n \n \nInt\n \ncount = 0\n;  \nFor each v in \nV,  count += v;   Collect(K\n, count\n); }\n \n<\nHello,1>\n \n<World,1>\n \n<Bye,1>\n \n<World,1>\n \n \n<Hello,1>\n \n<Hadoop,1>\n \n<Bye,1>\n \n<Hadoop,1>\n \n\n \n \n<Bye \n\n \n1, 1, 1\n>\n \n \n<Hadoop \n\n \n1, 1, 1, 1\n>\n \n \n<Hello \n\n \n1, 1, 1>\n \n \n \n<\nBye, 3\n>\n \n \n<\nHadoop, 4\n>\n \n \n<\nHello, 3\n>\n \n10\n \nSlide adapted from Alexander \nBehm\n \n& \nAjey\n \n\n://\nwww.slideshare.net/gothicane/behm\n-\nshah\n-\npagerank)\n \nReduce(K, V[ ])\n \nOutput\n \nReduce(K, V[ ])\n \nAfter \n \ninternal grouping\n \nReduce(K, V[ ])\n \nMap Output\n \n",
    "10": "11\n \nInverted Indexing with MapReduce\n \nBuilt\n-\nIn Shuffle and Sort: aggregate values by keys \n \nMap\n \nReduce\n \nD1: java resource java class\n \n\n \nKey               Value\n \njava               (D1, 2)  \n \nresource       (D1, 1)\n \nclass              (D1,1)\n \nKey               Value\n \njava               (D2, 1)  \n \ntravel            (D2,1)\n \nresource        (D2,1)\n \nKey               Value\n \njava               {(D1,2), (D2, 1)}  \n \nresource        {(D1, 1), (D2,1)}\n \nclass              {(D1,1)}\n \ntravel            {(D2,1)}\n \n\n \n\n \n",
    "11": "Inverted Indexing: Pseudo\n-\nCode\n \n\n \n12\n \n",
    "12": "Summary\n \n\nWeb scale indexing requires \n \n\nStoring the index on multiple machines (GFS)\n \n\nCreating the index in parallel (\nMapReduce\n) \n \n\nBoth GFS and \nMapReduce\n \nare general infrastructures\n \n \n13\n \n"
}