{"version":3,"file":"popup.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;ACAA;AACA,YAAY,mBAAO,CAAC,wEAAe;AACnC,qBAAqB,mBAAO,CAAC,qFAAoB;AACjD;;;;;;;;;;;ACHA,eAAe,mBAAO,CAAC,4EAAiB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtBA,eAAe,mBAAO,CAAC,4DAAY;AACnC,wBAAwB,mBAAO,CAAC,gFAAsB;;AAEtD;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,UAAU;AACrB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;;AAEA;;;;;;;;;;;ACxGA,aAAa,mBAAO,CAAC,sEAAqB;;AAE1C;AACA,iBAAiB,mBAAO,CAAC,6EAAuB;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4FAAQ,IAAe,kBAAkB,QAAQ,CAAC;AACjF;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxFA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,kCAAkC,GAAG;AACrC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCfA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNa;;AAEQ;AACrB,gBAAgB,mBAAO,CAAC,wDAAW;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA,yBAAyB,mCAAmC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,gCAAgC,UAAU,WAAW,WAAW;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,4E","sources":["webpack://my-extension/./src/popup.css","webpack://my-extension/./node_modules/sentiment/languages/en/index.js","webpack://my-extension/./node_modules/sentiment/languages/en/scoring-strategy.js","webpack://my-extension/./node_modules/sentiment/languages/ sync ^\\.\\/.*\\/index$","webpack://my-extension/./node_modules/sentiment/lib/index.js","webpack://my-extension/./node_modules/sentiment/lib/language-processor.js","webpack://my-extension/./node_modules/sentiment/lib/tokenize.js","webpack://my-extension/webpack/bootstrap","webpack://my-extension/webpack/runtime/hasOwnProperty shorthand","webpack://my-extension/webpack/runtime/make namespace object","webpack://my-extension/./src/popup.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","module.exports = {\n    labels: require('./labels.json'),\n    scoringStrategy: require('./scoring-strategy')\n};\n","var negators = require('./negators.json');\n\nmodule.exports = {\n    apply: function(tokens, cursor, tokenScore) {\n        if (cursor > 0) {\n            var prevtoken = tokens[cursor - 1];\n            if (negators[prevtoken]) {\n                tokenScore = -tokenScore;\n            }\n        }\n        return tokenScore;\n    }\n};\n","var map = {\n\t\"./en/index\": \"./node_modules/sentiment/languages/en/index.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./node_modules/sentiment/languages sync recursive ^\\\\.\\\\/.*\\\\/index$\";","var tokenize = require('./tokenize');\nvar languageProcessor = require('./language-processor');\n\n/**\n * Constructor\n * @param {Object} options - Instance options\n */\nvar Sentiment = function (options) {\n    this.options = options;\n};\n\n/**\n * Registers the specified language\n *\n * @param {String} languageCode\n *     - Two-digit code for the language to register\n * @param {Object} language\n *     - The language module to register\n */\nSentiment.prototype.registerLanguage = function (languageCode, language) {\n    languageProcessor.addLanguage(languageCode, language);\n};\n\n/**\n * Performs sentiment analysis on the provided input 'phrase'.\n *\n * @param {String} phrase\n *     - Input phrase\n * @param {Object} opts\n *     - Options\n * @param {Object} opts.language\n *     - Input language code (2 digit code), defaults to 'en'\n * @param {Object} opts.extras\n *     - Optional sentiment additions to AFINN (hash k/v pairs)\n * @param {function} callback\n *     - Optional callback\n * @return {Object}\n */\nSentiment.prototype.analyze = function (phrase, opts, callback) {\n    // Parse arguments\n    if (typeof phrase === 'undefined') phrase = '';\n    if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n    }\n    opts = opts || {};\n\n    var languageCode = opts.language || 'en';\n    var labels = languageProcessor.getLabels(languageCode);\n\n    // Merge extra labels\n    if (typeof opts.extras === 'object') {\n        labels = Object.assign(labels, opts.extras);\n    }\n\n    // Storage objects\n    var tokens      = tokenize(phrase),\n        score       = 0,\n        words       = [],\n        positive    = [],\n        negative    = [],\n        calculation = [];\n\n    // Iterate over tokens\n    var i = tokens.length;\n    while (i--) {\n        var obj = tokens[i];\n        if (!labels.hasOwnProperty(obj)) continue;\n        words.push(obj);\n\n        // Apply scoring strategy\n        var tokenScore = labels[obj];\n        // eslint-disable-next-line max-len\n        tokenScore = languageProcessor.applyScoringStrategy(languageCode, tokens, i, tokenScore);\n        if (tokenScore > 0) positive.push(obj);\n        if (tokenScore < 0) negative.push(obj);\n        score += tokenScore;\n        \n        var zipObj = {}; \n        // Calculations breakdown\n        zipObj[obj] = tokenScore;\n        calculation.push(zipObj);\n    }\n\n    var result = {\n        score:          score,\n        comparative:    tokens.length > 0 ? score / tokens.length : 0,\n        calculation:    calculation,\n        tokens:         tokens,\n        words:          words,\n        positive:       positive,\n        negative:       negative\n    };\n\n    // Handle optional async interface\n    if (typeof callback === 'function') {\n        process.nextTick(function () {\n            callback(null, result);\n        });\n    } else {\n        return result;\n    }\n};\n\nmodule.exports = Sentiment;\n","var emojis = require('../build/emoji.json');\n\n// English is loaded by default\nvar enLanguage = require('../languages/en/index');\n// Add emojis\nObject.assign(enLanguage.labels, emojis);\n\n// Cache loaded languages\nvar languages = {\n    en: enLanguage\n};\n\nmodule.exports = {\n\n    /**\n     * Registers the specified language\n     *\n     * @param {String} languageCode\n     *     - Two-digit code for the language to register\n     * @param {Object} language\n     *     - The language module to register\n     */\n    addLanguage: function (languageCode, language) {\n        if (!language.labels) {\n            throw new Error('language.labels must be defined!');\n        }\n        // Add emojis\n        Object.assign(language.labels, emojis);\n        languages[languageCode] = language;\n    },\n\n    /**\n     * Retrieves a language object from the cache,\n     * or tries to load it from the set of supported languages\n     *\n     * @param {String} languageCode - Two-digit code for the language to fetch\n     */\n    getLanguage: function(languageCode) {\n        if (!languageCode) {\n            // Default to english if no language was specified\n            return languages.en;\n        }\n        if (!languages[languageCode]) {\n            // Try to load specified language\n            try {\n                // eslint-disable-next-line max-len\n                var language = require('../languages/' + languageCode + '/index');\n                // Add language to in-memory cache\n                this.addLanguage(languageCode, language);\n            } catch (err) {\n                throw new Error('No language found: ' + languageCode);\n            }\n        }\n        return languages[languageCode];\n    },\n\n    /**\n     * Returns AFINN-165 weighted labels for the specified language\n     *\n     * @param {String} languageCode - Two-digit language code\n     * @return {Object}\n     */\n    getLabels: function(languageCode) {\n        var language = this.getLanguage(languageCode);\n        return language.labels;\n    },\n\n    /**\n     * Applies a scoring strategy for the current token\n     *\n     * @param {String} languageCode - Two-digit language code\n     * @param {Array} tokens - Tokens of the phrase to analyze\n     * @param {int} cursor - Cursor of the current token being analyzed\n     * @param {int} tokenScore - The score of the current token being analyzed\n     */\n    applyScoringStrategy: function(languageCode, tokens, cursor, tokenScore) {\n        var language = this.getLanguage(languageCode);\n        // Fallback to default strategy if none was specified\n        // eslint-disable-next-line max-len\n        var scoringStrategy = language.scoringStrategy || defaultScoringStrategy;\n        return scoringStrategy.apply(tokens, cursor, tokenScore);\n    }\n};\n\nvar defaultScoringStrategy = {\n    apply: function(tokens, cursor, tokenScore) {\n        return tokenScore;\n    }\n};\n","/*eslint no-useless-escape: \"off\"*/\n\n/**\n * Remove special characters and return an array of tokens (words).\n * @param  {string} input Input string\n * @return {array}        Array of tokens\n */\nmodule.exports = function(input) {\n    return input\n        .toLowerCase()\n        .replace(/\\n/g, ' ')\n        .replace(/[.,\\/#!?$%\\^&\\*;:{}=_`\\\"~()]/g, ' ')\n        .replace(/\\s\\s+/g, ' ')\n        .trim()\n        .split(' ');\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","'use strict';\n\nimport './popup.css';\nvar Sentiment = require('sentiment');\nconst openai_api_url = 'https://api.openai.com/v1/engines/text-davinci-003/completions';\n\nasync function queryGPT3(promptText) {\n  const response = await fetch(openai_api_url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer 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`\n    },\n    body: JSON.stringify({\n      //model: \"text-davinci-003\",\n      prompt: promptText,\n      max_tokens: 1500,\n      temperature: 0.5\n    })\n  });\n  console.log(response.status);\n  const data = await response.json();\n  return data.choices[0].text.trim();\n}\n\nfunction getText() {\n  var inputText = document.getElementById('inputText').value;\n  window.documentText = inputText.toLowerCase().match(/\\b(\\w+)\\b/g);\n  document.getElementById('result').textContent = \"Text Successfully Retrieved\";\n}\nfunction calculateTF(words) {\n  const wordCount = words.length;\n  const wordFreq = {};\n  words.forEach(word => {\n      wordFreq[word] = (wordFreq[word] || 0) + 1;\n  });\n  for (let word in wordFreq) {\n      wordFreq[word] = wordFreq[word] / wordCount;\n      //console.log(word + wordFreq[word]);\n  }\n  return wordFreq;\n}\n\nasync function calculateIDF() {\n  try {\n      const response = await fetch(chrome.runtime.getURL('IDF.json'));\n      const idfData = await response.json();\n      window.idf = idfData; // Now it's safe to assign to a global variable\n      // You can also return 'idfData' here\n      return idfData;\n  } catch (error) {\n      console.error('Error fetching the JSON file:', error);\n  }\n}\n// clean\nfunction calculateTFIDF(TF, IDF) {\n  let tfIdfScores = [];\n  const defaultIdf = 4; // Or calculate a dynamic default IDF value\n\n  // Calculate TF-IDF score for each term and push to array\n  for (const term in TF) {\n      const idf = term in IDF ? IDF[term] : defaultIdf;\n      tfIdfScores.push({ term: term, score: TF[term] * idf });\n  }\n  // Sort the array by TF-IDF score in descending order\n  tfIdfScores.sort((a, b) => b.score - a.score);\n  return tfIdfScores;\n}\n// clean\nasync function summarizeText(action) {\n  const tf = calculateTF(window.documentText);\n  //IDF part\n  const idf = await calculateIDF();\n  window.TFIDF = calculateTFIDF(tf, idf);\n  let keyword_size = 7;\n  if (documentText.length<50) keyword_size = 3;\n  if (documentText.length>1000) keyword_size=15;\n  const topTfIdfScores = TFIDF.slice(0, keyword_size);\n  let textContent = '';\n  for (const item of topTfIdfScores) {\n      // Assuming each item has 'term' and 'score' properties\n      textContent += `${item.term}\\n`\n      //textContent += `Term: ${item.term}, Score: ${item.score}\\n`;\n  }\n  document.getElementById('result').textContent = textContent;\n  //document.getElementById('result').textContent = window.tf;\n}\n\nfunction sentimentAnalysis() {\n  var sentiment = new Sentiment();\n  var result = sentiment.analyze(documentText.toString());\n  console.dir(result);\n  document.getElementById('result').textContent = result.score + \" \" + result.comparative;\n}\n\nfunction topicSummary() {\n  console.log(\"here\");\n  var promptText = \"Give me a very less than 30 word SUMMARY of : \" + window.documentText.toString();\n  console.log(promptText);\n  queryGPT3(\"promptText\").then(response => {\n    console.log(response);\n    document.getElementById('topicsummary').textContent = response;\n  }).catch(error => {\n    console.error('Error:', error);\n  });\n}\n\ndocument.getElementById('getTextButton').addEventListener('click', getText);\ndocument.getElementById('summarizeBtn').addEventListener('click', () => summarizeText('summarize'));\ndocument.getElementById('sentimentBtn').addEventListener('click', () => sentimentAnalysis('sentiment'));\ndocument.getElementById('topicBtn').addEventListener('click', topicSummary);"],"names":[],"sourceRoot":""}